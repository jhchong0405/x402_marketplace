export = CFX;
/**
 * @typedef { import('../Transaction').TransactionMeta } TransactionMeta
 */
declare class CFX extends RPCMethodFactory {
    constructor(conflux: any);
    _formatAddress: any;
    sendRawTransaction: (...args: any[]) => PendingTransaction;
    /**
     * Auto populate transaction
     * if from's privateKey is in wallet, directly sign and encode it then send the rawTransaction with `cfx_sendRawTransaction` method
     * if not, sent the transaction with `cfx_sendTransaction` method
     *
     * @param {TransactionMeta} options transaction info
     * @param {string} [password] Optional password to unlock account in fullnode
     * @return {Promise<string>} Transaction hash
     */
    sendTransaction(options: TransactionMeta, ...extra: any[]): Promise<string>;
    call: {
        (options: any, epochNumber: any): Promise<string>;
        request(options: any, epochNumber: any): {
            request: {
                method: string;
                params: any[];
            };
        };
    };
    estimateGasAndCollateral: {
        (options: any, epochNumber: any): Promise<cfxFormat.EstimateResult>;
        request(options: any, epochNumber: any): {
            request: {
                method: string;
                params: any[];
            };
            decoder: any;
        };
    };
    methods(): ({
        method: string;
        requestFormatters?: undefined;
        responseFormatter?: undefined;
        alias?: undefined;
        debug?: undefined;
    } | {
        method: string;
        requestFormatters: any[];
        responseFormatter: any;
        alias?: undefined;
        debug?: undefined;
    } | {
        method: string;
        responseFormatter: any;
        requestFormatters?: undefined;
        alias?: undefined;
        debug?: undefined;
    } | {
        method: string;
        alias: string;
        responseFormatter: any;
        requestFormatters?: undefined;
        debug?: undefined;
    } | {
        method: string;
        requestFormatters: any[];
        responseFormatter?: undefined;
        alias?: undefined;
        debug?: undefined;
    } | {
        method: string;
        alias: string;
        requestFormatters: any[];
        responseFormatter: any;
        debug?: undefined;
    } | {
        method: string;
        alias: string;
        requestFormatters: any[];
        responseFormatter?: undefined;
        debug?: undefined;
    } | {
        method: string;
        beforeHook(options: any): void;
        requestFormatters: any[];
        responseFormatter: any;
        alias?: undefined;
        debug?: undefined;
    } | {
        method: string;
        debug: boolean;
        requestFormatters: any[];
        responseFormatter: any;
        alias?: undefined;
    } | {
        method: string;
        debug: boolean;
        requestFormatters: any[];
        responseFormatter?: undefined;
        alias?: undefined;
    })[];
    _decoratePendingTransaction(func: any): (...args: any[]) => PendingTransaction;
    _addRequestBuilderToCall(): {
        (options: any, epochNumber: any): Promise<string>;
        request(options: any, epochNumber: any): {
            request: {
                method: string;
                params: any[];
            };
        };
    };
    _addRequestBuilderToEstimate(): {
        (options: any, epochNumber: any): Promise<cfxFormat.EstimateResult>;
        request(options: any, epochNumber: any): {
            request: {
                method: string;
                params: any[];
            };
            decoder: any;
        };
    };
    /**
     * Auto populate transaction info (chainId, epochNumber, nonce, gas, gasPrice, storageLimit)
     *
     * @param {TransactionMeta} options transaction info
     * @returns {Promise<TransactionMeta>} Polulated complete transaction
     */
    populateTransaction(options: TransactionMeta): Promise<TransactionMeta>;
    /**
     * Auto populate transaction and sign it with `from` 's privateKey in wallet
     *
     * @param {TransactionMeta} options transaction info
     * @returns {Promise<string>} Hex encoded raw transaction
     */
    populateAndSignTransaction(options: TransactionMeta): Promise<string>;
    /**
     * Get epoch's receipt through pivot block's hash
     *
     * @param {string} pivotBlockHash Hash of pivot block
     * @returns {Promise<Array>} All receipts of one epoch
     */
    getEpochReceiptsByPivotBlockHash(pivotBlockHash: string, ...extra: any[]): Promise<any[]>;
    /**
     * Virtually call a contract, return the output data.
     *
     * @param {TransactionMeta} options - See [Transaction](#Transaction.js/Transaction/**constructor**)
     * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](#util/format.js/format/(static)epochNumber)
     * @return {Promise<string>} The output data.
     */
    _call(options: TransactionMeta, epochNumber?: string | number): Promise<string>;
    /**
     * Virtually call a contract, return the estimate gas used and storage collateralized.
     *
     * @param {TransactionMeta} options - See [Transaction](#Transaction.js/Transaction/**constructor**)
     * @param {string|number} [epochNumber='latest_state'] - See [format.epochNumber](#util/format.js/format/(static)epochNumber)
     * @return {Promise<import('./types/formatter').EstimateResult>} A estimate result object:
     * - `BigInt` gasUsed: The gas used.
     * - `BigInt` gasLimit: The gas limit.
     * - `BigInt` storageCollateralized: The storage collateralized in Byte.
     */
    _estimateGasAndCollateral(options: TransactionMeta, epochNumber?: string | number): Promise<import('./types/formatter').EstimateResult>;
}
declare namespace CFX {
    export { TransactionMeta };
}
import RPCMethodFactory = require("./index");
import PendingTransaction = require("../subscribe/PendingTransaction");
type TransactionMeta = import('../Transaction').TransactionMeta;
import cfxFormat = require("./types/formatter");
//# sourceMappingURL=cfx.d.ts.map